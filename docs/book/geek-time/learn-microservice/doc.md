
## <font color=red>Overview</font>

> ##### <font color=green>微服务是什么</font>

微服务的概念最早是 Martin Fowler 和 James Lewis 提出: 是由单一应用程序构成的小服务, 
拥有自己的进程与轻量化处理, 服务依业务功能设计, 以全自动的方式部署, 与其他服务使用 http 通讯.

> ##### <font color=green>Monolithic Application 单体应用</font>

传统的单体应用架构, 就是将应用程序的所有功能都打包成一个独立的单元, 通常是 JAR, WAR, EAR 或 其它归档格式.

**<font color=red>优点:</font>** 对于业务规模不大, 开发团队规模小的时候, 单体应用能一定程度上控制开发和运维成本
- 早期的系统架构, 为人熟知, 学习成本低, 开发上手快
- 易于测试, 因为单体应用包含了所有功能, 没有外部依赖, 一旦部署就可以测试所有功能
- 容易部署, 以 MVC (Spring MVC, Hibernate, Tomcat) 为例, 通常是打成 war 包部署到 tomcat, 然后启动 tomcat,
监听端口, 即可对外提供服务

**<font color=red>缺点:</font>** 当业务规模不断扩大, 开发人员跨团队协作等情况下, 单体应用就会表现出以下问题
- 部署效率低下, 当业务代码越来越多, 依赖的各种资源就越来越多, 编译打包部署一次, 将耗费大量时间
- 团队协作成本高, 当多个开发人员共同修改代码, 因为功能耦合一起, 其中一个功能有问题就需要所有开发人员重新参与其中
- 系统高可用性低, 所有代码都在部署在一个 war 的 tomcat 进程, 因此当一块代码有问题, 很容易导致整个程序不可用
- 不够灵活, 影响持续交付, 因为多个开发人员共同开发一个应用程序, 这就要求必须等到所有人都完成各自开发之后, 才能交付
- 技术栈限制, 单体应用要求使用同一开发语言, 同时单体应用各种功能代码耦合性搞, 难于重构

> ##### <font color=green>服务化</font> 

随着业务的快速发展, 敏捷性, 灵活性, 可扩展性等要求越来越高; 这时的单体应用只会越来越臃肿, 而团队的协作效率低下, 
以及各个功能模块的耦合, 会导致交付变得更加困难. 

服务化是一种可以满足这种快速持续交付的架构设计, **<font color=red>简单来说: 服务化就是把单体应用在进程间通过 JAR
包依赖产生的本地方法调用, 改造成通过 RPC 接口产生的远程方法调用</font>**, 它把复杂的单体应用根据业务功能, 
划分成不同的模块, 每个模块有各自的团队独立开发, 测试, 部署, 同时向外暴露出接口, 各个模块间通过 RPC 相互调用.
这样减少了系统间的代码耦合, 一个模块出问题, 不会导致整个系统的不可用, 同时只需要修复对应的模块, 快速启动.

> ##### <font color=green>Microservice 微服务</font>

随着容器化技术的流行, 服务化思想逐渐被落地实施, 演变成当下主流的微服务架构设计. 

**<font color=red>优点:</font>** 系统被拆分成多个细粒度的子模块, 因此会有以下优势 
- 每个服务独立部署, 易于开发, 维护
- 不受技术栈限制, 可以采用不同的开发语言
- 服务间通过接口交互, 降低耦合 
- 故障隔离, 单个服务故障不会导致整个系统不可用

**<font color=red>缺点:</font>** 微服务会把单体应用的技术债务从开发转到运维
- 服务被拆分的粒度越细, 服务治理就越困难, 对应的运维成本就会越高 

## <font color=red>Monolith-to-MicroService</font>

> ##### <font color=green>服务化拆分</font>

当遇到上述单体架构的问题, 同时开发团队足够支撑微服务架构的时候, 我们可以尝试将单体架构转化为微服务. 将单体应用
拆分为多个微服务, 通常由两种拆分策略:
- 纵向拆分:
  
- 横向拆分:
